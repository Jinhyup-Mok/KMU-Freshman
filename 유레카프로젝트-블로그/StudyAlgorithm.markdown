---
layout: page
title: Study Algorithm
---
## 알고리즘이란?

- 컴퓨터를 이용하여 주어진 과제를 해결하기 위한 저리 절차를 의미 합니다.
- 주어진 문제 해결을 위한 처리 절차라고 할 수 있습니다.
- 현실 세계의 다양한 과제의 해결에 있어서도 알고리즘의 개념이 사용 됩니다.

***프로그래밍 언어를 배웠다고 해서 주어진 문제 해결을 할 수 있는 것은 아니다. 주어진 문제를 해결하기 위해서는 알고리즘적인 사고와 많은 훈련이 필요 하다.***

-----------
## 알고리즘의 조건

- 입력 : 알고리즘은 0 또는 그 이상의 외부에서 제공된 자료가 존재
- 출력 : 알고리즘은 최소 1개 이상의 결과가 있어야 함.
- 명확성 : 알고리즘의 각 단계는 애매함 없는 명확한 과정으로 구성되어야 한다.
- 유한성 : 알고리즘은 유한한 수의 단계를 수행한 후 문제가 해결되고 종료 되어야 한다.
- 효율성 : 알고리즘의 모든 연산은 명백하게 실행 할 수 있음을 검즐 할 수 있어야 한다.

-----------
## 알고리즘의 종류

1. **기술 계산 : 기술 계산을 위한 알고리즘**
- 유클리드 호제법(최대공약수)
- 가우스 소거법(방정식)
- 사다리꼴의 법칙(정적분)
- 데이크스트라 알고리즘(최적 경로)
- 에라토스테네스의 체(소수)
1. **정렬**
- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 셀 정렬
- 병합 정렬
- 퀵 정렬
1. **검색**
- 선형 검색
- 이진 검색
1. **문자열 패턴 매칭**
- 단순 문자열 일치
- KMP 알고리즘
- BM 알고리즘

-----------
## 알고리즘의 기초가 되는 구조적 프로그램

1. 순차 구조 : 작성된 순서대로 순차 실행 한다.
2. 선택 구조 : 조건에 따라 수행할 작업의 흐름을 바꾼다.
3. 반복 구조 : 조건이 참인 동안 일정 과정을 반복 수행 한다.

-----------
## 알고리즘 평가의 세가지 요소

### 시간의 효율성

시간의 효율성은 모든 알고리즘에서 가장 중요하게 생각하는 요소 입니다.

컴퓨터에서 실행되는 프로그램이라면 주어진 조건에 맞춰 문제를 해결하는 데 무한대의 시간을 사용 할 수 없습니다. 

예) 순차 검색과 이분 검색

1000개의 값을 기준으로 검색 한다면 순차 검색은 최대 1000회, 이분 검색은 9회만에 검색이 완료 됩니다

```python
#include <stdio.h>
#include <stdlib.h>

int main() {
    int i, val;
    int cnt = 0;
    int data[10000];
    srand(time(NULL));
    val = (rand() % 10000) + 1;
    for (i = 0; i< 10000; i++) {
        data[i] = i + 1;
    }
    start = clock();
    for (i = 0; i < 10000; i++) {
        cnt++;
        if(val == data[i]) {
            printf("index : %d\n", i+1);
            break;
        }
    }
    printf("총 검색 횟수는 : %d입니다.\n", cnt);
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int i, val, mid;
    int min = 0, max = 9999, cnt = 0;
    int data[10000];
    srand(time(NULL));
    val = (rand() % 10000) + 1;
    for (i = 0; i< 10000; i++) {
        data[i] = i + 1;
    }
    while(min <= max) {
        mid = (min + max) / 2;
        cnt++;
        if(val == data[i]) {
            printf("index : %d\n", i+1);
            break;
        } else if(val < data[i]) max = mid - 1;
        else min = mid + 1;
    }
    printf("총 검색 횟수는 : %d입니다.\n", cnt);
}
```
-----------
### 공간의 효율성

공간의 효율성은 컴퓨터에서 사용하는 메모리와 관계가 있다.

사례1)

```c
#include <stdio.h>
int main() {
	int i;
	int data[1000];
	for(i = 0; i < 10; i++) {
		data[i] = i;
	}
```

사례2)

- 전역 변수

```c
#include <stdio.h>
int Add(void);
int Subtract(void);
// 지역 변수로 사용할 변수를 전역 변수로 선언했다
int Num_A, Num_B;
int ret;
int Add(void) {
	return Num_A + Num_B;
}

```
-----------
### 코드의 효율성

코드의 효율성은 프로그래머 입장에서 보는 코드의 효율성과 컴퓨터의 입장에서 보는 코드의 효율성이 있다.

첫 번째, 프로그래머 입장에서 보는 코드의 효율성은 가독성Readability이 좋은 코드를 의미한다.

**`b = ++(a-- *++c) / ++d;`** // 가독성에 좋지 않음

재귀 호출이나 비효율적인 데이터형 사용등은 컴퓨터 효율성에서는 좋지 않음. 불필요한 실수 사용도 효율성이 좋지 않음

-----------
### 알고리즘과 자료구조

int arr[3] = {10,20,30};  // 자료 구조

for(i = 0; i < 3; i++) {  // 알고리즘

sum += arr[i]

}

-----------
### 빅오표기법

**O(1)** 

처리해야 할 데이터양과 상관없이 항상 일정한 실행 시간을 갖는 알고리즘

**O(logN)**

처리해야 할 데이터양이 증갈할수록 실행 시간도 약간 증가하는 알고리즘이다. 일반적으로 효율이 높은 검색 알고리즘이 해당 된다.

**O(N)**

처리해야 할 데이터양과 비례해 실행 시간이 증가하는 경우 (1부터 100까지 더하는 반복문)

재귀호출도 여기에 해당 된다.

**O(NlogN)**

처리해야 할 데이터양보다 실행 시간이 좀 더 빠르게 증가한다. 효율이 높은 정렬 알고리즘이 해당 된다.

**O(N2)**

반복문이 2번 중첩된 경우의 알고리즘

```c
for(i = 0; i < N; i++) {
 for(j = 0; j < N; j++) {
 }
}
```

**O(N3)**

반복문이 3번 중첩된 경우의 알고리즘

데이터양이 증가하면 실행 시간은 그의 세제곱만큼 증가하므로 좋은 알고리즘이라고 볼 수 없다.
